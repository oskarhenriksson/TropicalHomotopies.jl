
"""
    tropical_homotopies_from_homotopy_data(systems,pertubations,intersection_points)

Converts tropical intersection data (for instance  the auxilarly data from the Oscar function
`tropical_root_bound_with_homotopy_data`) into HomotopyContinuation.jl homotopies.

"""
function tropical_homotopies_from_homotopy_data(systems,pertubations,intersection_points; verbose=false)
    homotopies = tropical_homotopies_in_oscar_from_homotopy_data(systems,pertubations,intersection_points, verbose=verbose)
    return export_homotopy_from_oscar_to_HC.(homotopies)
end

function tropical_homotopies_in_oscar_from_homotopy_data(systems,pertubations,intersection_points; verbose=false)
    T = tropical_semiring(min)
    nu = tropical_semiring_map(QQ,min)
    Qx = parent(first(first(systems)))
    Qt, t = rational_function_field(QQ,"t") #todo: change to laurent_polynomial_ring when https://github.com/oscar-system/Oscar.jl/discussions/3156 is fixed
    Qtx, x = polynomial_ring(Qt, symbols(Qx))
    homotopies = [] #todo: add type
    for w in intersection_points
        homotopy_w = []
        for (system,u) in zip(systems,pertubations)
            r = lcm(denominator.(Vector(w-u)))
            shift = Int.(Vector(r*Vector(w-u)))
            system_GB = groebner_basis(ideal(system),nu,shift)
            system_shifted = evaluate.(system_GB,Ref(t.^(shift) .* x))
            valuation_shift = -Int.(evaluate.(tropical_polynomial.(system_GB),Ref(shift)))
            homotopy_w = vcat(homotopy_w, (t.^valuation_shift).*system_shifted )
        end
        push!(homotopies,homotopy_w)
    end
    return homotopies
end


function export_homotopy_from_oscar_to_HC(homotopy)
    zipped_homotopy = []
    for h in homotopy
        exponent_vectors = collect(exponents(h))
        coefficient_values = map(c->Rational(coeff(numerator(c),degree(numerator(c)))),coefficients(h))
        t_exponents = degree.(numerator.(coefficients(h)))
        hzipped = zip(coefficient_values,exponent_vectors,t_exponents)
        push!(zipped_homotopy, hzipped)
    end
    n = ngens(parent(first(homotopy)))
    HC.@var t z[1:n]
    return HC.Homotopy( [ sum([ c*prod(z.^e)*t^a for (c,e,a) in hzipped]) for hzipped in zipped_homotopy] , z, t)
end

function start_system(H::HC.ModelKit.Homotopy) 
    return HC.System(HC.subs(H.expressions,H.t=>0))
end

function solve_binomial_system(F::HC.ModelKit.System)
    system_exponents, system_coefficients = HC.support_coefficients(F)
    @req all(isequal(2),length.(system_coefficients)) "Input system must be binomial"
    A = hcat( (E->E[:,1]-E[:,2]).(system_exponents)... )
    b = (c->-c[2]//c[1]).(system_coefficients)
    BSS = HC.BinomialSystemSolver(A,b)
    HC.solve!(BSS)
    return [Vector(BSS.X[:,i]) for i=1:size(BSS.X,2)]
end


function HC_system_from_Oscar_system(polynomial_system)
    n = ngens(parent(first(polynomial_system)))
    HC.@var x[1:n]
    zipped_system = [  zip(Rational.(coefficients(f)),exponents(f)) for f in polynomial_system ]
    return HC.System([ sum([ c*prod(x.^e) for (c,e) in fzipped]) for fzipped in zipped_system], variables=x)
end

function parametric_HC_system_from_parametric_Oscar_system(polynomial_system)
    n = ngens(parent(first(polynomial_system)))
    m = ngens(coefficient_ring(first(polynomial_system)))
    HC.@var a[1:m] x[1:n]
    zip_coefficients = c -> zip(Rational.(coefficients(c)),exponents(c))
    zipped_system = [  zip(  zip_coefficients.(coefficients(f)) ,exponents(f)) for f in polynomial_system ]
    unzip_coefficient = czipped -> sum([d*prod(a.^e) for (d,e) in czipped])
    return HC.System([ sum([ unzip_coefficient(c)*prod(x.^e) for (c,e) in fzipped]) for fzipped in zipped_system], parameters=a, variables=x)
end

function approximately_unique_vectors(lst::Vector{Vector{ComplexF64}}; tol=1e-10)
    unique_lst = Vector{ComplexF64}[]
    for item in lst
        if all(norm(item - x,Inf) > tol for x in unique_lst)
            push!(unique_lst, item)
        end
    end
    return unique_lst
end


"""
    tropical_solve(systems::Vector{Vector{QQMPolyRingElem}}; verbose=1, detour=true, print_result = false)

Solves a square system numerically given a list `systems` of disjoint subsystems, using the homotopies derived 
from the stable intersection of the tropicalizations of the ideals generated by the subsystems.

"""
function tropical_solve(systems::Vector{Vector{QQMPolyRingElem}}; verbose=1, detour=true, print_result = false)
    n = ngens(parent(first(first(systems)))) #todo: check that all systems have the same parent ring
    root_count, pertubations, intersection_points, mults = tropical_root_bound_with_homotopy_data(systems, verbose=verbose, print_result=print_result)
    homotopies = tropical_homotopies_from_homotopy_data(systems,pertubations,intersection_points, verbose=verbose)
    all_solutions = Vector{ComplexF64}[]
    time_start_systems = 0
    time_tracing = 0
    # Todo: Should this be its own function?
    for H in homotopies
        S = start_system(H)
        time_start_systems += @elapsed start_solutions = solve_binomial_system(S)
        for s in start_solutions
            if detour
                t1 = exp(2*pi*rand()*im)
                time_tracing += @elapsed result1 = HC.track(HC.Tracker(H),s,0.0,t1)
                s1 = result1.solution
            else 
                t1 = 0.0
                s1 = s
            end
            time_tracing += @elapsed result = HC.track(HC.Tracker(H),s1,t1,1)
            if result.return_code == :success
                push!(all_solutions,result.solution[1:n])
            end
        end
    end
    if verbose >= 3
        println("Time spent solving start systems: ",time_start_systems)
        println("Time per path: ", time_tracing/root_count)
    end
    if verbose >= 2
        println("Time spent tracing paths: ",time_tracing)
    end
    all_solutions = approximately_unique_vectors(all_solutions)
    if verbose >= 1
        println("Number of paths traced: ", root_count)
        println("Number of solutions found: ", length(all_solutions))
        println()
    end
    return all_solutions
end




